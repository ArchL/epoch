(* Example from Solidity by Example
   http://solidity.readthedocs.io/en/develop/common-patterns.html

   contract WithdrawalContract {
     address public richest;
     uint public mostSent;

      mapping (address => uint) pendingWithdrawals;

      function WithdrawalContract() payable {
        richest = msg.sender;
        mostSent = msg.value;
      }

      function becomeRichest() payable returns (bool) {
        if (msg.value > mostSent) {
            pendingWithdrawals[richest] += msg.value;
            richest = msg.sender;
            mostSent = msg.value;
            return true;
        } else {
            return false;
        }
      }

      function withdraw() {
        uint amount = pendingWithdrawals[msg.sender];
        // Remember to zero the pending refund before
        // sending to prevent re-entrancy attacks
        pendingWithdrawals[msg.sender] = 0;
        msg.sender.transfer(amount);
      }
  }

*)

contract WithdrawalContract

state = { .richest  : Address = 0,
          .mostSent : Uint    = 0,
          .pendingWithdrawals : Map Address => Uint = [] }

fun becomeRichest() returns (Bool) =
    if (@call.value > @state.mostSent) then
        let totalAmount:Uint = pendingWithdrawals[@state.richest] + @call.value in
            {.state = @state[ .pendingWithdrawals = @state.pendingWithdrawals[@state.richest] = @call.value,
                             .richest = @call.sender,
                             .mostSent = @call.value],
             .return = true}
     else
         {.return = false}


fun withdraw()
    let amount:Uint = @state.pendingWithdrawals[@call.sender] in
        { .state = @state[ @state.pendingWithdrawals[@call.sender] = 0],
          .transactions = spend_tx(amount, @call.sender)
        }
