(*
contract AeToken {
	function balanceOf(address addr) returns (uint256);
}

contract AEProof {

	AeToken aeToken;
	mapping (bytes32 => Proof) private proofs;
	mapping (address => bytes32[]) private proofsByOwner;

	function AEProof(address tokenAddress) {
		aeToken = AeToken(tokenAddress);
	}

	struct Proof {
		address owner;
		uint timestamp;
		uint proofBlock;
		string comment;
		string ipfsHash;
		string document;
	}

	function notarize(string document, string comment, string ipfsHash) onlyTokenHolder {
		var proofHash = calculateHash(document);
		var proof = proofs[proofHash];
		require(proof.owner == address(0));
		proof.owner = msg.sender;
		proof.timestamp = block.timestamp;
		proof.proofBlock = block.number;
		proof.comment = comment;
		proof.ipfsHash = ipfsHash;
		proof.document = document;

		proofsByOwner[msg.sender].push(proofHash);
	}

	function calculateHash(string document) constant returns (bytes32) {
		return sha256(document);
	}

	function getProof(string document) constant returns (address owner, uint timestamp, uint proofBlock, string comment, string ipfsHash, string storedDocument) {
		var calcHash = calculateHash(document);
		var proof = proofs[calcHash];
		require(proof.owner != address(0));
		owner = proof.owner;
		timestamp = proof.timestamp;
		proofBlock = proof.proofBlock;
		comment = proof.comment;
		ipfsHash = proof.ipfsHash;
		storedDocument = proof.document;
	}

	function getProofByHash(bytes32 hash) constant returns (address owner, uint timestamp, uint proofBlock, string comment, string ipfsHash, string storedDocument) {
		var proof = proofs[hash];
		require(proof.owner != address(0));
		owner = proof.owner;
		timestamp = proof.timestamp;
		proofBlock = proof.proofBlock;
		comment = proof.comment;
		ipfsHash = proof.ipfsHash;
		storedDocument = proof.document;
	}

	function hasProof(string document) constant returns (bool) {
		var calcHash = calculateHash(document);
		var storedProof = proofs[calcHash];
		if (storedProof.owner == address(0)) {
			return false;
		}
		return true;
	}

	function getProofsByOwner(address owner) constant returns (bytes32[]) {
		return proofsByOwner[owner];
	}

	modifier onlyTokenHolder() {
		uint balance = aeToken.balanceOf(msg.sender);
		require(balance > 0);
		_;
	}
}
*)

import contract aetoken
fun balanceOf(addr : Address) : UInt 
    
contract aeproof

export notarize, getProof, getProofByHash, hasProof, getProofsByOwner

type Proof: { .owner: Address
            , .timestamp: UInt
            , .proofBlock: UInt
            , .comment: String
            , .ipfsHash: String
            , .document: String
            }

               
type State: { aeToken : contract = aetoken,
              proofs  : Map UInt => Proof,
              proofsByOwner : Map Address > UInt[]}

fun notarize(document:String, comment:String, ipfsHash:String) =
    let _ = require(aetoken.balanceOf(@caller) > 0) in 
        proofHash:UInt = calculateHash(document),
        proof:Proof = @state.proofs[profHash],
        _ = require(proof.owner == #0),
        proof':Proof = proof with { .owner = @caller
                                  , .timestamp = @block.timestamp
		                  , .proofBlock = @block.height
                                  , .comment = comment
                                  , .ipfsHash = ipfsHash
		                  , .document = document
                                  } in
            { state: @state with { .proofsByOwner with .proofsByOwner[@caller] = proofHash,
                                   .proofs with proofs[proofHash] = proof' } }

                   
pure fun calculateHash(document:Strng) : UInt = sha256(document)

fun getProof(document String) : Proof =
  let calcHash = calculateHash(document)
    , proof = @state.proofs[calcHash] 
    , _ = require(proof.owner != #0) in
      { return = proof }

fun getProofByHash(hash: UInt) : Proof =
  let proof = @state.proofs[hash]
    , _ = require(proof.owner != #0) in
      { return = proof }


const fun hasProof(document: String):Bool =
        let calcHash = calculateHash(document)
             , storedProof = @state.proofs[calcHash] in
            { return = (storedProof.owner != #0) }

const fun getProofsByOwner(owner: Address): UInt[] =
	{return = @state.proofsByOwner[owner]}
          
pure fun require x:Bool = if x then () else abort

